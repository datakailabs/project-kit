package shell

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"time"

	"github.com/datakaicr/pk/pkg/config"
)

// GenerateAliases creates shell alias file for all projects
func GenerateAliases(shell Shell, projects []*config.Project) error {
	aliasFile := ConfigPath(shell)

	// Ensure directory exists
	dir := filepath.Dir(aliasFile)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	// Create temp file
	tempFile := aliasFile + ".tmp"
	f, err := os.Create(tempFile)
	if err != nil {
		return fmt.Errorf("failed to create temp file: %w", err)
	}
	defer f.Close()

	// Write header
	writeHeader(f, shell)

	// Separate projects by category
	datakai := []*config.Project{}
	active := []*config.Project{}
	archived := []*config.Project{}

	for _, p := range projects {
		// DataKai ecosystem (special handling)
		if p.ProjectInfo.ID == "conduit" || p.ProjectInfo.ID == "dk" || p.ProjectInfo.ID == "dkos" {
			datakai = append(datakai, p)
			continue
		}

		// Categorize others
		if p.ProjectInfo.Status == "archived" {
			archived = append(archived, p)
		} else {
			active = append(active, p)
		}
	}

	// Write DataKai ecosystem
	writeSection(f, shell, "DataKai Ecosystem", datakai)

	// Special DataKai aliases
	writeDataKaiSpecial(f, shell)

	// Write active projects
	writeSection(f, shell, "Active Projects", active)

	// Write archived projects
	writeArchivedSection(f, shell, archived)

	// Write special aliases
	writeSpecialAliases(f, shell)

	// Move temp to final location
	if err := os.Rename(tempFile, aliasFile); err != nil {
		return fmt.Errorf("failed to move alias file: %w", err)
	}

	return nil
}

func writeHeader(f *os.File, shell Shell) {
	switch shell {
	case Zsh, Bash:
		fmt.Fprintf(f, "# =============================================================================\n")
		fmt.Fprintf(f, "#  Auto-generated Project Aliases\n")
		fmt.Fprintf(f, "#  Generated by: pk sync\n")
		fmt.Fprintf(f, "#  DO NOT EDIT MANUALLY - Changes will be overwritten\n")
		fmt.Fprintf(f, "# =============================================================================\n\n")
		fmt.Fprintf(f, "# Last updated: %s\n\n", time.Now().Format("2006-01-02 15:04:05"))
	case Fish:
		fmt.Fprintf(f, "# Auto-generated Project Aliases\n")
		fmt.Fprintf(f, "# Generated by: pk sync\n")
		fmt.Fprintf(f, "# Last updated: %s\n\n", time.Now().Format("2006-01-02 15:04:05"))
	}
}

func writeSection(f *os.File, shell Shell, title string, projects []*config.Project) {
	if len(projects) == 0 {
		return
	}

	// Sort by ID
	sort.Slice(projects, func(i, j int) bool {
		return projects[i].ProjectInfo.ID < projects[j].ProjectInfo.ID
	})

	switch shell {
	case Zsh, Bash:
		fmt.Fprintf(f, "# ---------- %s ----------\n", title)
	case Fish:
		fmt.Fprintf(f, "# %s\n", title)
	}

	for _, p := range projects {
		// Skip 'pk' to avoid conflict with pk command
		if p.ProjectInfo.ID == "pk" {
			continue
		}
		writeAlias(f, shell, p.ProjectInfo.ID, p.Path, "")
	}

	fmt.Fprintf(f, "\n")
}

func writeArchivedSection(f *os.File, shell Shell, projects []*config.Project) {
	if len(projects) == 0 {
		return
	}

	sort.Slice(projects, func(i, j int) bool {
		return projects[i].ProjectInfo.ID < projects[j].ProjectInfo.ID
	})

	switch shell {
	case Zsh, Bash:
		fmt.Fprintf(f, "# ---------- Archived Projects ----------\n")
	case Fish:
		fmt.Fprintf(f, "# Archived Projects\n")
	}

	for _, p := range projects {
		// Skip 'pk' to avoid conflict with pk command
		if p.ProjectInfo.ID == "pk" {
			continue
		}
		comment := fmt.Sprintf("archived %s", p.Dates.Completed)
		writeAlias(f, shell, p.ProjectInfo.ID, p.Path, comment)
	}

	fmt.Fprintf(f, "\n")
}

func writeDataKaiSpecial(f *os.File, shell Shell) {
	homeDir, _ := os.UserHomeDir()

	// Check if dojo exists in monorepo
	dojoPath := filepath.Join(homeDir, "projects", "dk", "apps", "dojo")
	if _, err := os.Stat(dojoPath); err == nil {
		writeAlias(f, shell, "dojo", dojoPath, "")
	}

	// Check if vision docs exist
	visionPath := filepath.Join(homeDir, "projects", "dk", "docs", "vision")
	if _, err := os.Stat(visionPath); err == nil {
		writeAlias(f, shell, "vision", visionPath, "")
	}

	fmt.Fprintf(f, "\n")
}

func writeSpecialAliases(f *os.File, shell Shell) {
	homeDir, _ := os.UserHomeDir()
	dojoPath := filepath.Join(homeDir, "projects", "dk", "apps", "dojo")

	switch shell {
	case Zsh, Bash:
		fmt.Fprintf(f, "# ---------- Special Aliases ----------\n")
		if _, err := os.Stat(dojoPath); err == nil {
			fmt.Fprintf(f, "alias dojo-db='cd %s && source apps/web/.env.local && psql $DATABASE_URL'\n", dojoPath)
		}
	case Fish:
		fmt.Fprintf(f, "# Special Aliases\n")
		if _, err := os.Stat(dojoPath); err == nil {
			fmt.Fprintf(f, "function dojo-db\n")
			fmt.Fprintf(f, "    cd %s\n", dojoPath)
			fmt.Fprintf(f, "    source apps/web/.env.local\n")
			fmt.Fprintf(f, "    psql $DATABASE_URL\n")
			fmt.Fprintf(f, "end\n")
		}
	}
}

func writeAlias(f *os.File, shell Shell, name, path, comment string) {
	switch shell {
	case Zsh, Bash:
		if comment != "" {
			fmt.Fprintf(f, "alias %s=\"cd %s\"  # %s\n", name, path, comment)
		} else {
			fmt.Fprintf(f, "alias %s=\"cd %s\"\n", name, path)
		}
	case Fish:
		if comment != "" {
			fmt.Fprintf(f, "abbr -a %s 'cd %s'  # %s\n", name, path, comment)
		} else {
			fmt.Fprintf(f, "abbr -a %s 'cd %s'\n", name, path)
		}
	}
}
